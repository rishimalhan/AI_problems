# -*- coding: utf-8 -*-
"""A6_Rishi_Malhan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-87YK9axmHK7LHD9LhEBDF3KO8XGQY7o

**Assignment-6**
Rishi Malhan
rmalhan@usc.edu
"""

# 1. Download the data.npy file from blackboard and load the data to your Google colab. (Check this
# stackoverflow question and links within it to learn how to load data to Google Colab).
from google.colab import drive
drive.mount('/content/drive')

import numpy as np
from scipy.spatial import distance_matrix
from sklearn.cluster import KMeans
from matplotlib import pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import scipy.linalg as la
import math

def GetEigenPairs(data):
  sigma = 0.1
  # Weight Matrix
  W = np.exp( - np.square(distance_matrix(data,data,p=2) / sigma) )
  # Degree matrix
  D = np.diag( np.sum(W,axis=1) )
  # Laplacian
  L = D-W
  return la.eig(L)

if __name__=='__main__':
  data = np.load("/content/drive/My Drive/Colab Notebooks/data.npy")
  (eigVal, eigVec) = GetEigenPairs(data)

sortVal = np.sort( np.absolute(eigVal) )
  sortIdx = np.argsort( np.absolute(eigVal) )
  sortVec = eigVec[:,sortIdx]

  plt.rcParams["figure.figsize"] = (8,6)

  # Plotting first few Eigen Values to determine the spectral gap
  plt.semilogy( sortVal[0:20] )
  plt.title("Eigen Values Vs Index")

  n_clusters = 1
  for i in range(1, len(sortVal)):
    if (sortVal[i] - sortVal[i-1]) < 1e-1:
      n_clusters += 1
    else:
      break

  n_clusters = np.where( sortVal <= 1e-1 )[0].shape[0]
  print("Number of Clusters: ", n_clusters)

  coords = sortVec[:,0:n_clusters]
  kmeans = KMeans(n_clusters=n_clusters)
  kmeans.fit(coords)
  # Cluster labels
  pred = kmeans.fit_predict(coords)

  plt.rcParams["figure.figsize"] = (20,10)

  fig,axs = plt.subplots(1,3)
  # X-Y subplot
  axs[0].scatter( data[:,0],data[:,1],c=pred )
  # X-Z subplot
  axs[1].scatter( data[:,0],data[:,2],c=pred )
  # Y-Z subplot
  axs[2].scatter( data[:,1],data[:,2],c=pred )

  fig = plt.figure()
  ax = fig.add_subplot(111, projection='3d')
  ax.scatter( data[:,0],data[:,1],data[:,2],c=pred )